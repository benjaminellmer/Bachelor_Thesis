\chapter{Project Structure}
\label{cha:project_structure}
This chapter aims to show the concrete structure and communication of an project, which implements the previously discussed authentication mechanisms.
The focus of this chapter is showing the effects of the different authentication mechanisms to the project itself.
For the simplicity topics like authorization, key management and user context sharing are not handled in this chapter.
The visualizations are based on the backend of a flea market app.

\section{Flea Market App}
The flea market app is an Android App written in the programming language Kotlin.
The main features are buying, renting and swapping items.
The user is authenticated using firebase authentication.
He has to present his access token to the Microsoft API Gateway with each request.
The backend of the app is based on the microservice architecture.
The microservice are mainly implemented in C\# using the ASP.Net Core framework.
Actually the backend contains the following services:
\begin{itemize}
	\item AdService
	\item UserService
	\item ChatService
	\item MediaService
	\item SubscriptionService
	\item ReportService
\end{itemize}
Each service has its own PostgreSQL database.
The services are hosted on Microsoft Azure using docker containers.
Only the AdService and the UserService will be used to show an the communication within the deployment of the project using the discussed authentication mechanisms.

\section{Communication among the Components}
Figure~\ref{fig:deployment_communication} visualizes the communication among the services for an example use case.
In this example the user fetches all ads which are in his surrounding.
Therefore the AdService is used to retrieve the ads from the database and the UserService is needed to preview information about the seller.
The following components are necessary for the declared use case:
\begin{description}
	\item[Android App:] The Android App is the User Interface for the client to access the functionalities of the services.
		The requests sent by the Android App are sent in beyond of the user.
	\item[Firebase:] The Firebase Authentication service is responsible for validating the access tokens wich are transferred by the users.
		The app also communicates with this service to get an access token, but this is done in an earlier stage.
	\item[API Gateway:] The API Gateway is the only entry point into the deployment.
		Therefore the API Gateway is the only component which directly communicates to the Android App.
	\item[AdService:] The AdService is responsible to manage all ads offered to the user of the app.
	\item[UserService:] The AdService is the service which is responsible for managing the users. 
\end{description}

\begin{figure}
	\centering
	\tikzset{
		every picture/.append style={
			transform shape,
			scale=0.85
		}
	}
	\begin{sequencediagram}
		\newthread{app}{:Android App}{}
		\newinst[1]{gateway}{:API Gateway}{}
		\newinst[1]{fa}{:Firebase}{}
		\newinst[1]{as}{:AdService}{}
		\newinst[1]{us}{:UserService}{}

		\begin{call}{app}{\shortstack{request$_{1}$}}{gateway}{response$_1$}
			\begin{call}{gateway}{access token}{fa}{validity}
			\end{call}
			\begin{sdblock}{if}{validity == true}
				\begin{call}{gateway}{request$_1$}{as}{response$_1$}
					\begin{call}{as}{request$_2$}{us}{reponse$_2$}
					\end{call}
				\end{call}
			\end{sdblock}
		\end{call}
	\end{sequencediagram}
	%\includegraphics[width=0.7\textwidth]{images/project-structure/sequence-structure.pdf}
	\caption{Communication among the components of the flea market app}
	\label{fig:deployment_communication}
\end{figure}

\subsection{Workflow using mTLS}
\begin{enumerate}
	\item[1.] The client sends an API request to the Microsoft API Gateway using the Android App.
		The communication between the API Gateway and the App is secured using HTTPS.
		Therefore the server is authenticated to the client using TLS.
		The client is authenticated to the server by embedding an firebase access token within the Authorization header.
	\item[2.] The API Gateway sends the received token to the Firebase Authentication service to validate it.
		This procedure is defined as a policy within the policy file of the API Gateway.
		\\
	\item[3.] The Firebase Authentication service returns the information whether the persented token is valid or not.
	\item[4.] When the client provided a valid access token, the request of the client is forwarded to the \textbf{AdService}.
		The communication between the API Gateway and the \textbf{AdService} is secured using mTLS.
		This means both parties have to present a certificate, signed by a trusted CA.
		Therefore the webserver of the \textbf{AdService} has to be configured to allow or even require Client Certificates.
	\item[5.] After processing the request from the API Gateway the \textbf{AdService} sends a request to the \textbf{UserService} to retrieve the additional information about the owner.
		The communication between the \textbf{UserService} and the \textbf{AdService} is also protected using mTLS, so it has to be configured like the \textbf{AdService}.
		The certificate is appened to the request using a HTTPClient, which is injected to the Controller of the WebService using Dependency Injection.
	\item[6.] When the \textbf{UserService} processed the request, it responds with the expected result.
		The response does not require to perform the authentication again, since TCP connection between the \textbf{AdService} and the \textbf{UserService} is still opened.
	\item[7.] After the \textbf{AdService} processed the response from the \textbf{UserService}, it uses the opened connection with the API Gateway and transfers its response.
	\item[8.] The API Gateway forwards the response from the \textbf{AdService} to the Android App.
		This connection is still secured using TLS and not mTLS.
		The App can now process the response and present the requested information to the user.
\end{enumerate}

\subsection{Workflow using JWT}
The workflow using JWT and the workflow using mTLS are very similar, therefore only the steps which differ between the mechanisms are described again.
\begin{enumerate}
	\item[4.] The request from the client is forwarded to the \textbf{UserService}. 
		Therefore the API Gateway has to create a valid JWT to communicate with the \textbf{UserService}.
		On the Microsoft API Gateway, the logic to create a JWT is implemented as a policy.
		The JWT, which is signed using the private key of the API Gateway is transferred within the Authorization header.
	\item[5.] The \textbf{AdService} has to retrieve additional information from the \textbf{UserService}.
		Now the \textbf{AdService} has to present his JWT to the \textbf{UserService}.
		This is done by using a HTTPClientFactory, which automatically embeds the signed JWT within the Authorization header, when the request is sent.
		If the \textbf{AdService} does not know the certificate of the \textbf{UserService}, it will deny the request and ask the \textbf{AdService} to present its certificate.
		In this case the request is repeated and the certificate of the \textbf{AdService} is transferred during the TLS handshake, like it would be transferred using mTLS.
\end{enumerate}

\section{Implementation Details}

\subsection{mTLS} \label{sec:impl_details_mtls}
As already discussed in chapter~\ref{cha:authentication_mechanisms}, the implementation of mutual TLS does not require very much logic on the service-side.
The best way to implement mTLS, in a ASP.Net Core API is using the \textbf{Microsoft.AspNetCore.Authentication.Certificate} library.
It provides the mechanism to add certificate authentication as \textbf{AuthenticationScheme} and implement custom \textbf{CertificateAuthenticationEvents}.
The \textbf{CertificateAuthorityService}, implements the interface \textbf{ICertificateAuthorityService} which is shown in listing~\ref{lst:ICertificateAuthorityService}.
It provides features to manage a custom certificate truststore and validate certificates using this truststore.
An instance of the \textbf{CertificateAuthorityService} is injected to the \textbf{CertificateAuthenticationEvents}.
The depenendency injection is managed by the \textbf{Microsoft.Extensions.DependencyInjection} library.
The \textbf{UseAuthentication} and \textbf{UseAuthorization} functions of the \textbf{ApplicationBuilder} have to be called to use the created \textbf{AuthenticationScheme}.
The functions of the API Controllers have to be marked with the \textbf{[Authorize]} annotation, to require the client to be authenticated to consume the function.
Therefore it is possible to exclude some functionalities from the certificate authentication.

The client side does not require much logic either.
The client has to attach his certificate to the request.
In ASP.Net this is done, by creating a custom \textbf{HTTPHandler}, and setting the \textbf{ClientCertificate} property.
The \textbf{HTTPHandler} is then used to create a \textbf{HTTPClient}, which is used to perform the requests.
It is good practise to create the \textbf{HTTPClient} once and then inject it into the Controllers using dependency injection.
This helps improving the performance and especially prevents, that the certificate of the service has to be parsed multiple times.

\noindent \begin{minipage}{\linewidth}
	\begin{CsCode}[label={lst:ICertificateAuthorityService}, caption={ICertificateAuthorityService interface, which is implemented by the injected CertificateAuthorityService},captionpos=b]
		public interface ICertificateAuthorityService {
			public void AppendCertificate(X509Certificate2 certificate);
			public bool ValidateCertificate(X509Certificate2 certificate);
		}
	\end{CsCode}
\end{minipage}

\subsection{JWT}
The best way to implement the authentication using self-signed JWTs in ASP.Net Core is a custom middleware.
% TODO: Faktencheck
A custom middleware provides the possibility to perform actions on the receiving request before, they are handled by the API Controllers.
The \textbf{JWTAuthenticationMiddleware} validates the JWT and the certificates of all received request.
The validation is performed like it is shown in~\ref{alg:jwt}.
When a client certificate is transferred within the TLS handshake, it is checked using a service that implements the \textbf{ICertificateAuthorityService}, which was shown in listing~\ref{lst:ICertificateAuthorityService}.
If the certificate is valid, it is mapped to the issuer of the certificate within a custom truststore of the \textbf{JWTValidationService}.
The \textbf{JWTValidationService} implements the \textbf{ITokenValidationService} interface which is shown in listing~\ref{lst:ITokenValidationService}.
Both the \textbf{CertificateAuthorityService} and the \textbf{JWTValidationService} are injected into the \textbf{Invoke} function of the \textbf{JWTAuthenticationMiddleware} using dependecy injection.

\noindent \begin{minipage}{\linewidth}
	\begin{CsCode}[label={lst:ITokenValidationService}, caption={ITokenValidationService interface, which is implemented by the injected JWTValidationService},captionpos=b]
		public interface ITokenValidationService {
			public bool PutIntoTruststore(X509Certificate2 certificate);
			public bool ContainsIssuerInTruststore(String issuer);
			public bool ValidateTokenWithTruststore(String token, string issuer);
			public bool ValidateTokenWithTruststore(String token);
		}
	\end{CsCode}
\end{minipage}

The client has to implement the logic for creating JWTs and attaching them to the requests within the Authorization header.
The JWTs are created, using the \textbf{JWTCreatorService} that implements the \textbf{ITokenCreatorService} which is shown in~\ref{lst:ITokenCreatorService}.
The \textbf{JWTCreatorService} and a \textbf{HTTPClient} are injected to the API Controllers using dependency injection.
The Controllers can choose between two clients, one that contains the certifcte of the service and one that does not contain any additional data.
In both cases the Controller has to use the \textbf{JWTCreatorService} to create a JWT and append it to the Authorization header of each request.
An authentication JWT, which is created using the \textbf{JWTCreatorService} is shown in figure~\ref{fig:jwt_en_decoded}.

\noindent \begin{minipage}{\linewidth}
	\begin{CsCode}[label={lst:ITokenCreatorService}, caption={ITokenCreatorService interface, which is injected to the API Controllers},captionpos=b]
		public interface ITokenCreatorService {
			public string CreateToken(string audience);
		}
	\end{CsCode}
\end{minipage}

\begin{figure}
	\begin{centering}
	\end{centering}
	\textcolor{red}{eyJhbGciOiJSUzI1NiIsImtpZCI6IkYwMURFNTBCNTU5MzVBQ0VEOUNDNzdCRjR\\FMjY5NkVDOTE4MUI5NjkiLCJ0eXAiOiJKV1QifQ}.
	\textcolor{blue}{eyJuYmYiOjE2NDU1MjU5MjM\\sImV4cCI6MTY0NTUyNjIyMywiaXNzIjoic2VydmljZTEuc3dhcGluZG8uY29tIiwiYXV\\kIjoic2VydmljZTIuc3dhcGluZG8uY29tIn0}.
	\\ 
	\begin{Verbatim}[commandchars=\\\{\}]
\textcolor{red}{\{} 
	\textcolor{red}{"alg": "RS256",}
	\textcolor{red}{"kid": "F01DE50B55935ACED9CC77BF4E2696EC9181B969",}
	\textcolor{red}{"typ": "JWT"} 
\textcolor{red}{\}}
\textcolor{blue}{\{} 
	\textcolor{blue}{"nbf": 1645525923,}
	\textcolor{blue}{"exp": 1645526223,}
	\textcolor{blue}{"iss": "service1.swapindo.com",}
	\textcolor{blue}{"aud": "service2.swapindo.com"} 
\textcolor{blue}{\}}
	\end{Verbatim}
	\caption{Header and Payload of a JWT, created by the JWTCreatorService}
	\label{fig:jwt_en_decoded}
\end{figure}

\begin{algorithm}[H]
	\caption{Pseudocode of the request validation using self-signed JWTs}\label{alg:jwt}
	\begin{algorithmic}
		\State $certificate \gets request.Connection.ClientCertificate$
		\State $token \gets request.Headers[Authorization]$
		\State $missingCertificate \gets false$

		\If{$token$ is $null$}
		\State $response.StatusCode \gets 403Forbidden$
		\State $authenticated \gets false$
		\Else
		\State $issuer \gets null$
		\If{$certificate$ is not $null$}
		\If{$certificate$ is $trusted$}
		\If{$putCertificateIntoTruststore(certificate)$ is $successful$}
		\State $issuer \gets certificate.subject$
		\EndIf
		\EndIf
		\Else
		\If{$containsIssuerInTruststore(token.issuer)$}
		\State $issuer \gets token.issuer$
		\Else
		\State $missingCertificate \gets true$
		\EndIf
		\EndIf

		\If{$issuer$ is not $null$ \&\& $validateJWT(token)$ is $valid$}
		\State $authenticated \gets true$
		\Else
		\If{$missingCertificate$ is $true$}
		\State $response.StatusCode \gets 401Unauthorized$
		\Else
		\State $response.StatusCode \gets 403Forbidden$
		\EndIf
		\State $authenticated \gets false$
		\EndIf
		\EndIf
	\end{algorithmic}
\end{algorithm}

\section{Conclusion}
This chapter showed an concrete project which implements the previously discussed authentication concepts.
Furthermore, some details were shown to give an idea how the concepts can be implemented.
The implementation details also prooved that the authentication mechanism using self-sigend JWTs requires more code than the implementation using mTLS.
The aim of this implementation was to clarify, what the services have to do when they send and receive requests and responses.
The concrete implementation differs between the used programming language and the used technologies.
