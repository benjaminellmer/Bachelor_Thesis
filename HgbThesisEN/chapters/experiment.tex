\chapter{Experiment}
\label{cha:experiment}
This chapter shows an experiment, where the performance of the two discussed authentication mechanisms is compared.
Even if the performance is not the major decision point to choose the correct authentication mechanism, it is still worth considering it.
Especially, because the migration from a monolithic architecture to the microservice architecture already results in a massive performance decrease of around 79.1\%~\cite{ueda2016workload}.
Therefore the performance is already restricted, and the authentication mechanisms should not produce too much overhead.

\section{Experiment Setup}
The setup consists of two components, the service, that responds to requests and the client, which performs requests and measures the taken time.
The service of this experiment is developed in C\# using ASP.Net Core, same as the services of the flea market app, mentioned in chapter~\ref{cha:project_structure}.
The client is a console application, developed in C\# using .NET.
It is not a microservice, but it acts as a service that is located within the deployment.
In a usual deployment it is not good practice to access the services directly from an external application, bypassing the API Gateway.
Nevertheless, for the purpose of an experiment, this is allowed to make the setup simpler. 

The experiment consists of two test cases.
In the first test case, the console application fetches random numbers from the service.
Therefore the service does not have to establish any connection to a database.
% TODO: geht das nicht besser ?
The abosulte duration of this test case will not be very meaningful, because it is very unrealistic, that a service considers another service for a task like creating a random number.
But the trend of this times gives a good value for the comparison of the authentication mechanisms, since the falsification of other operations like accessing a database is minimized.
In the second case, the console application fetches all users stored in a database table.
The difference between the two test cases will show how much time has is accounted to the authentication mechanisms and how much time is accounted to other tasks.

The console application tracks the whole time, which is needed to perform one request not only the time that is needed by the service to respond.
This experiment should not give an approximation of the expected request durations with the declared technology stack.
Instead it will compare the trends between the authentication mechanisms.
The exact duration times are neglected, since they are influenced by many factors, like the hardware of the server and the client.

The experiment simulates the situation that a service (the console application) performs 1000 requests to another service.
The connection between the client and the server has to be established, when the first request is performed.
Therefore the first request will take significantly longer, since the full TCP handshake and TLS handshake has to be performed.
All other request can reuse the already created connection and do not have to perform the whole initialisation process again.
The tests were performed five times to minimize distortions between the test runs.

The experiment will compare the two authentication mechanisms, which were describe in chapter~\ref{cha:authentication_mechanisms}.
Two different implementations of the approach using self-signed JWTs are demonstrated.
First, an implementation of the self-signed JWT approach, in which a new JWT is created for each request is shown.
The second implementation uses the same JWT for all requests.
This is a very rare case, since it is unlikely that the exact same request is performed multiple times.
But it should give an idea how simple the performance can be increased by caching the JWTs.

%\subsection{Test Device Specifications}

\section{Experimental Results}

\begin{table}[H]
\begin{tabular}{c|cc}
\multicolumn{1}{l|}{\textbf{Authentication Mechanism}} & \multicolumn{2}{c}{\textbf{Average Request Duration}} \\ \hline
\multicolumn{1}{c|}{} & \multicolumn{1}{c|}{first connection} & reusing connection \\ \hline
mTLS & \multicolumn{1}{c|}{$199.66$ ms} & $10.18$ ms \\ \hline
self-signed JWT & \multicolumn{1}{c|}{$226.83$ ms} & $15.38$ ms \\ \hline
self-signed JWT (reusing token) & \multicolumn{1}{c|}{$216.1$ ms} & $8.75$ ms
\end{tabular}
\caption{Average request durations of the authentication mechanisms, when random numbers are fetched}
\label{tab:experiment_case_1}
\end{table}

The results of the first experiment case are shown in table~\ref{tab:experiment_case_1}.
The lowest duration for the first connection is achieved using mTLS.
This is toally reasonable, since mTLS does only have to perform the TLS handshake, when the connection is established.



